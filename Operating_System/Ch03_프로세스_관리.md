# 프로세스 관리


### 프로세스의 개념

* 실행 중인 프로그램
* 프로세스의 문맥(context)
  * CPU 수행 상태를 나타내는 하드웨어 문맥 : 프로세스가 어디까지 실행했는지를 나타낸다.
    * Program Counter
    * 각종 register
  * 프로세스의 주소 공간 : 메모리에 어떤 정보를 가지고 있는지를 나타낸다.
    * code, data, stack
  * 프로세스 관련 커널 자료 구조
    * PCB(Process Control Block)
    * Kernel stack

### 프로세스의 상태(state)

* Running : CPU를 잡고 instruction을 수행 중인 상태
  * CPU는 한 번에 하나의 프로세스만 사용 가능하기에 하나의 프로세스만 running 상태가 된다.
* Ready : CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족하고)
  * 프로세스가 메모리에 존재해야 한다.
* Blocked(wait, sleep)
  * CPU를 주어도 당장 instruction을 수행할 수 없는 상태
  * Process 자신이 요청한 event(ex : I/O)가 즉시 만족되지 않아 이를 기다리는 상태
  * 공유 데이터를 기다리고 있는 경우에도 Blocked 상태가 될 수 있다.
  * ex) 디스크에서 file을 읽어와야 하는 경우
* 기타 상태
  * New : 프로세스가 생성 중인 상태
  * Terminated : 수행(execution)이 끝난 상태
* 운영체제는 PCB를 통해 각 프로세스가 어떤 상태인지를 인지하고 각 프로세스를 상태에 따라 적절한 큐에 배치한다.
* 입출력 작업이 끝나면 인터럽트가 발생해 운영체제가 프로세스의 입출력 작업이 끝났음을 인지하고 I/O queue에 있던 프로세스를 ready queue로 옮겨준다.

![프로세스_관리_1](https://user-images.githubusercontent.com/70595250/154790030-9b2913f4-c8e5-4731-880a-0beb13d76ddd.PNG)

### Process Control Block(PCB)

* 운영체제가 각 프로세스를 관리하기 위해 프로세스마다 유지하는 정보
* 구성 요소(구조체로 유지)
  * OS가 관리상 사용하는 정보
    * Process State, Process ID
    * scheduling information, priority
  * CPU 수행 관련 하드웨어 값
    * Program Counter, registers
  * 메모리 관련
    * Code, data, stack의 위치 정보
  * 파일 관련
    * open file descriptors, ...
    
### 문맥 교환(Context Switch)

* CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정
* CPU가 다른 프로세스에게 넘어갈 때 운영체제는 CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장하고 CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어온다.
* PCB에 CPU 수행 관련 하드웨어 값을 저장하는 이유
* System call이나 Interrupt 발생시 반드시 context switch가 발생하지는 않는다.
  * 사용자 프로세스에서 커널로 CPU가 넘어가는 경우는 context switch가 아니다. (단, context 일부를 PCB에 저장하기 해야 함)
  * timer interrupt나 I/O 요청 system call로 인해 한 사용자 프로세스에서 다른 사용자 프로세스로 CPU가 넘어갈 때만 context switch라고 한다.
* context switch를 하는 경우 단순히 커널로 CPU가 넘어갔다가 자기 자신으로 돌아오는 경우보다 부담이 훨씬 크다. (ex : cache memory flush - 다른 사용자 프로세스에 CPU를 할당할 때 캐시 메모리를 모두 비워야 한다.)

### 프로세스를 스케줄링하기 위한 큐

* Job queue : 현재 시스템 내에 있는 모든 프로세스의 집합
* Ready queue : 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
* Device queue : I/O device의 처리를 기다리는 프로세스의 집합

### 스케쥴러(Scheduler)

* Long-term scheduler(장기 스케줄러)
  * 시작 프로세스 중 어떤 것들을 ready queue로 보낼지 결정
  * 프로세스에 memory 및 각종 자원을 주는 문제
  * degree of Multiprogramming(메모리에 올라가는 프로세스의 개수)을 제어
  * time sharing system에는 보통 장기 스케줄러가 없다.(무조건 ready)
* Short-term scheduler(단기 스케줄러)
  * 어떤 프로세스를 다음번에 running시킬지 결정
  * 프로세스에 CPU를 주는 문제
  * 충분히 빨라야 한다.
* Medium-term scheduler(중기 스케줄러)
  * 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄
  * 프로세스에게서 memory를 뺏는 문제
  * degree of Multiprogramming을 제어
  
### 프로세스의 추가 상태

* Suspended(stopped)
  * 외부적인 이유로 프로세스의 수행이 정지된 상태
  * 프로세스는 통째로 디스크에 swap out된다.
  * ex) 사용자가 프로그램을 일시 정지시킨 경우, 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)
* Blocked는 프로세스가 계속 실행 중인 상태로, 자신이 요청한 event가 만족하면 ready 상태가 된다.
* Suspended는 외부에서 resume해 주어야 active
* 운영체제가 프로세스 상태를 가지지는 않는다. 이러한 상태는 사용자 프로세스를 관리하기 위해 만든 상태이기 떄문이다.
  * 사용자 프로세스가 system call을 한 경우, 실행 중에 외부에서 interrupt가 온 경우 운영체제 커널이 CPU를 할당받게 되는데, 이를 사용자 프로세스가 커널 모드에서 running 상태가 됐다고 말한다.

![프로세스_관리_2](https://user-images.githubusercontent.com/70595250/154798719-3c0ba98f-f438-4fa5-97cf-33ac3dd4c1d8.PNG)

### Thread

* 프로세스의 CPU 수행 단위
* 스레드들은 프로세스의 data와 code는 공유하되(task) stack과 program counter, registers는 각자 별도로 가지고 있다.
* 동일한 프로세스에서 한 스레드에서 다른 스레드로 넘어갈 때 context switch를 하지 않아도 돼 overhead가 줄어든다.
* 다중 스레드로 구성된 태스크 구조에서는 하나의 서버 스레드가 blocked 상태인 동안에도 동일한 태스크 내 다른 스레드가 실행되어 빠른 처리를 할 수 있다.
* 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율과 성능 향상을 얻을 수 있다.
* 스레드를 사용하면 병렬성을 높일 수 있다.

### Thread의 구현

* Kernel Thread
  * 운영체제가 각 프로세스 내 스레드의 존재를 알고 있는 경우
  * 운영체제가 스레드 단위로 CPU scheduling한다.
* User Thread
  * 운영체제가 각 프로세스 내 스레드의 존재를 모르는 경우
  * 프로세스 내부에서 한 스레드가 입출력을 요청할 경우 운영체제에게 비동기식 입출력을 요청하고 다른 스레드에게 CPU를 할당한다.
  
### 프로세스 생성

* 부모 프로세스가 자식 프로세스 (복제) 생성
  * 운영체제에게 시스템 콜(fork()라는 함수 호출)을 해 자식 프로세스를 만들어 달라는 요청을 한다.
* 프로세스의 트리(계층 구조) 형성
* 프로세스는 자원을 필요로 한다.
  * 운영체제로부터 받는다.
  * 부모와 공유한다.
* 자원의 공유
  * 부모와 자식이 모든 자원을 공유하는 모델
  * 일부를 공유하는 모델
  * 전혀 공유하지 않는 모델
* 수행(Execution)
  * 부모와 자식은 공존하며 수행되는 모델
  * 자식이 종료될 때까지 부모가 기다리는(wait) 모델
  
### 프로세스 생성

* 주소 공간(Address space)
  * 자식은 부모의 공간을 복사한다.
  * 자식은 그 공간에 새로운 프로그램을 올린다.
  * 전역 변수, 스택 등을 그대로 복사한다.
* 유닉스의 예
  * fork() 시스템 콜이 새로운 프로세스를 생성
    * 부모를 그대로 복사
    * 주소 공간 할당
  * fork 다음에 이어지는 exec() 시스템 콜을 통해 새로운 프로그램을 덮어씌워 메모리에 올림
  
### 프로세스 종료

* 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려준다.(exit)
  * 자식이 부모에게 output data를 보낸다.(via wait)
  * 프로세스의 각종 자원들이 운영체제에게 반납된다.
* 부모 프로세스가 자식의 수행을 종료시킨다.(abort)
  * 자식이 할당 자원의 한계치를 넘어서는 경우
  * 자식에게 할당된 태스크가 더 이상 필요하지 않는 경우
  * 부모가 종료(exit)하는 경우
    * 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
    * 단계적인 종료
    
### fork() 시스템 콜

* fork() 함수를 호출하면 프로세스 하나가 복제되어 생성된다.
* 자식 프로세스는 부모 프로세스의 코드, 데이터, 스택을 복제하기 때문에 fork() 이후 코드를 그대로 수행한다.
* 따라서 부모 프로세스는 fork()의 결과값으로 자식 프로세스의 PID(양수)를, 자식 프로세스는 fork()의 결과값으로 0을 받아 이를 구분한다.

### exec() 시스템 콜

* 자식 프로세스의 주소 공간에 새로운 프로그램을 덮어씌운다.
* 해당 함수 호출 이후 부분은 실행되지 않는다.

### wait() 시스템 콜

* 프로세스 A가 wait() 시스템 콜을 호출하면 
  * 커널은 자식 프로세스가 종료할 때까지 프로세스 A를 sleep시킨다.(blocked 상태)
  * 자식 프로세스가 종료되면 커널은 프로세스 A를 깨운다.(ready 상태)
* 부모 프로세스가 자식 프로세스의 종료될 때까지 기다리는 경우

### exit() 시스템 콜

* 프로세스의 종료
* 자발적 종료
  * 마지막 statement 수행 후 exit() 시스템 콜을 통해 이루어진다.
  * 프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어준다.
* 비자발적 종료
  * 부모 프로세스가 자식 프로세스를 강제 종료시킴
    * 자식 프로세스가 한계치를 넘어서는 자원 요청
    * 자식에게 할당된 태스크가 더 이상 필요하지 않음
  * 키보드로 kill, break 등을 친 경우
  * 부모가 종료하는 경우
    * 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨
    
### 프로세스 간 협력

* 독립적 프로세스 : 프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함
* 협력 프로세스 : 프로세스 협력 매커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음
* 프로세스 간 협력 매커니즘(IPC : Interprocess Communication)
  * 메시지를 전달하는 방법(message passing)
    * 커널을 통해 메시지 전달
    * direct communication : 통신하려는 프로세스의 이름을 명시적으로 표시
    * indirect communication : mailbox(또는 port)를 통해 메시지를 간접 전달
  * 주소 공간을 공유하는 방법
    * shared memory : 서로 다른 프로세스 간에도 일부 주소 공간을 공유하게 하는 shared memory 매커니즘이 있음
    * thread : thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 process를 구성하는 thread들 간에는 주소 공간을 공유하므로 협력이 가능