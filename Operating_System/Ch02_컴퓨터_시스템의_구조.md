# 컴퓨터 시스템의 구조


![컴퓨터_시스템_구조](https://user-images.githubusercontent.com/70595250/153753540-d1e38c1c-a495-4952-a3b6-b10a0bd6383b.PNG)


### Mode bit


* 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하는 보호 장치
* 하드웨어적으로 두 가지 모드의 operation 지원
  * 1 - 사용자 모드 : 사용자 프로그램 수행
  * 0 - 모니터 모드(=커널 모드, 시스템 모드) : OS 코드 수행
* 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 __특권명령__으로 규정
* Interrupt나 Exception 발생 시 하드웨어가 mode bit를 0으로 바꾼다.
* 사용자 프로그램에게 CPU를 넘거기 전에 mode bit를 1로 바꾼다.


### Timer


* 프로그램의 CPU 독점을 막기 위한 하드웨어
* 일정 시간마다 interrupt를 발생시켜 프로그램이 일정 시간 동안만 CPU를 사용하도록 제한한다.
* time sharing을 구현하기 위해 널리 이용된다.
  

### I/O Device Controller


* I/O 장치를 관리하는 작은 CPU
* local buffer를 가진다.
* Device Controller는 운영체제로부터 입출력 명령을 받아 I/O 작업을 수행하고 I/O가 끝나면 Interrupt로 CPU에 그 사실을 알린다.
  * 그러면 CPU를 할당받은 프로그램이 인터럽트를 받아 중단되고 운영체제가 이를 인지해 I/O 결과를 I/O 요청 프로그램에게 전달한다.
* device driver(장치 구동기) : OS 코드 중 각 장치별 처리루틴(운영체제 안에 있는 코드) -> software
* device controller(장치 제어기) : 각 장치를 통제하는 일종의 작은 CPU -> hardware
* device controller는 장치 내 구현된 명령어인 펌웨어로 실행된다.
  

### Interrupt


* 인터럽트 당한 시점의 레지스터와 PC를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
* interrupt의 분류
  * Interrupt(하드웨어 인터럽트) : 디스크, 타이머 등 하드웨어가 발생시킨 인터럽트
  * Trap(소프트웨어 인터럽트) : 개별 프로그램이 운영체제에게 CPU를 넘기기 위해 발생시킨 인터럽트
    * Exception : 프로그램이 오류를 범한 경우
    * System call : 프로그램이 커널 함수를 호출하는 경우
* 프로그램은 매번 명령어를 실행한 후에 인터럽트 라인을 확인해 인터럽트가 들어온 게 있는지 확인한다.
* 인터럽트 벡터 : 해당 인터럽트의 처리 루틴 주소를 가지고 있다.
* 인터럽트 처리 루틴(인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수
* 현대의 운영체제는 인터럽트에 의해 구동된다. 아무 일도 하지 않다가 인터럽트가 들어오면 실행된다.
  

### System Call
  
  
* 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
* 프로그램이 파일 읽기 등 입출력이 필요한 경우 입출력 장치에 요청해야 하는데, 이에 해당하는 명령은 특권명령이다. 이러한 경우 system call을 통해 interrupt를 직접 걸어 운영체제에게 입출력을 요청한다.
  

### 동기식/비동기식 입출력


* 동기식 입출력(synchronous I/O)
  * I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에게 넘어감
  * 구현 방법 1 : I/O가 끝날 때까지 CPU를 낭비시킴. 매시점 하나의 I/O만 일어날 수 있음
  * 구현 방법 2 : I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음. 
    * I/O 처리를 기다리는 중에 그 프로그램을 줄 세움
    * 다른 프로그램에게 CPU를 줌
    * 1번 방법에 비해 훨씬 효율적
    * 여러 I/O가 동시에 일어날 수 있다.
* 비동기식 입출력(asynchronous I/O)
  * I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 즉시 넘어감
  * 파일을 읽지 않아도 수행할 수 있는 코드가 있는 경우, 파일을 쓰는 경우
* 두 경우 모두 I/O의 완료는 인터럽트로 알려줌
  

### DMA(Direct Memory Access)


* 인터럽트도 일종의 overhead -> 고속 I/O 장치에 의해 인터럽트가 지나치게 많이 일어나면 CPU의 성능 저하 
* 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
* CPU의 중재 없이 device controller가 device의 buffer storage 내용을 메모리에 block 단위로 직접 전송
* 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴 -> 인터럽트 발생 빈도가 낮아짐


### 서로 다른 입출력 기계어
  
  
* I/O를 수행하는 special instruction에 의해 : 메모리 접근 기계어와 I/O 접근 기계어가 따로 있음
* Memory Mapped I/O에 의해 : 메모리 주소를 메모리에만 부여하지 않고 I/O 장치에도 메모리 주소를 연장해 메모리 접근 기계어를 통해 I/O 장치에 접근
  

### 저장장치 계층 구조


* (registers - cache memory - main memory) (Primary(Executable)) - (magnetic disk - optical disk - magnetic tape) (Secondary)
* 왼쪽으로 갈수록 빠르지만 휘발성이고 단위 크기당 비용이 비싸다. 오른쪽으로 갈수록 느리지만 비휘발성이고 단위 크기당 비용이 싸다.
* caching : 매번 데이터를 확인할 때마다 느린 저장장치에 접근하는 것은 비효율적이므로 더 빠른 저장장치에 데이터를 복사해 데이터 접근 속도를 높이는 것
  
